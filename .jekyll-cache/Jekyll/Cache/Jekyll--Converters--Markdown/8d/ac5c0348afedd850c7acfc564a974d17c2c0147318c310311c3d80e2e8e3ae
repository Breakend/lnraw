I"4J<h3 id="symmetry-metrics-for-balanced-tree-forests">Symmetry Metrics for Balanced Tree Forests</h3>
<p>The goal is to understand how <code>nauty</code> output and symmetry metrics behave when we consider a forest with multiple disconnected trees. This situation would occur if we calculated symmetries across the entire set of trait trees when capturing statistics.</p>
<p>Some statistics, such as orbits, might crosscut trait trees if two trait trees shared adjacency relationships. In other situations, I’d expect them to be a disjoint union of results, and thus the statistics might simply be additive (and thus needing to be normalized by the number of configured trait trees). In other cases, such as <span class="math inline">\(|\textit{Aut}(G)|\)</span>, the relationship might be multiplicative and combinatorial.</p>
<p>I proceed by constructing a union graph of 2 balanced trait trees, then 3 and 4, and examining how the <code>nauty</code> output statistics scale. Then I look at a combination of different balanced trees. In the code sections below, I rely upon the <a href="https://github.com/mmadsen/axelrod-ct">axelrod-ct simulation model</a> available from my Github repository, Brendan McKay’s <code>nauty</code> library, and the Python <code>networkx</code> module.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">    <span class="im">import</span> networkx <span class="im">as</span> nx</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="im">import</span> madsenlab.axelrod.analysis <span class="im">as</span> stats</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="im">import</span> madsenlab.axelrod.utils <span class="im">as</span> utils</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">    conf <span class="op">=</span> utils.TreeStructuredConfiguration(<span class="st">&quot;dummyconf.json&quot;</span>)</a>
<a class="sourceLine" id="cb1-6" title="6">    conf.branching_factor <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb1-7" title="7">    conf.depth_factor <span class="op">=</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">    sym <span class="op">=</span> stats.BalancedTreeAutomorphismStatistics(conf)</a>
<a class="sourceLine" id="cb1-10" title="10">    g1 <span class="op">=</span> nx.balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-11" title="11">    g2 <span class="op">=</span> nx.balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="bu">print</span> sym.calculate_graph_symmetries(g1)</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15">    {<span class="st">&#39;radius&#39;</span>: <span class="dv">4</span>, <span class="st">&#39;orbitcounts&#39;</span>: [<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">16</span>, <span class="dv">64</span>, <span class="dv">256</span>], <span class="st">&#39;remainingdensity&#39;</span>: <span class="fl">1.0</span>, <span class="st">&#39;orbits&#39;</span>: <span class="dv">5</span>, <span class="st">&#39;groupsize&#39;</span>: <span class="fl">2.079483819622e+117</span>}</a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17">    order_tree <span class="op">=</span> stats.num_nodes_balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb1-18" title="18">    starting_vertex <span class="op">=</span> order_tree </a>
<a class="sourceLine" id="cb1-19" title="19">    g2A <span class="op">=</span> nx.convert_node_labels_to_integers(g2, first_label <span class="op">=</span> starting_vertex)</a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21">    graphs <span class="op">=</span> []</a>
<a class="sourceLine" id="cb1-22" title="22">    graphs.append(g1)</a>
<a class="sourceLine" id="cb1-23" title="23">    graphs.append(g2A)</a></code></pre></div>
<p>Below is the output for a forest with two trees with <span class="math inline">\(r=4, h=4\)</span>. We can see that the orbit number is the same, the multiplicities are simply different because the members of each orbit in each tree are interchangeable, so each multiplicity is twice the value in a single tree. The group size is much larger than twice, however, but we should expect there to be a multiplicative effect given that automorphisms scale as <span class="math inline">\(n!\)</span> for the complete graphs <span class="math inline">\(K_n\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">    <span class="bu">print</span> sym._get_raw_nauty_output(forestd)</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dv">5</span> orbits<span class="op">;</span> grpsize<span class="op">=</span><span class="fl">8.648505912135e234</span><span class="op">;</span> <span class="dv">511</span> gens<span class="op">;</span> <span class="dv">121276</span> nodes<span class="op">;</span> maxlev<span class="op">=</span><span class="dv">409</span></a>
<a class="sourceLine" id="cb2-4" title="4">    cpu time <span class="op">=</span> <span class="fl">0.38</span> seconds</a>
<a class="sourceLine" id="cb2-5" title="5">     <span class="dv">0</span> <span class="dv">341</span> (<span class="dv">2</span>)<span class="op">;</span> <span class="dv">1</span>:<span class="dv">4</span> <span class="dv">342</span>:<span class="dv">345</span> (<span class="dv">8</span>)<span class="op">;</span> <span class="dv">5</span>:<span class="dv">20</span> <span class="dv">346</span>:<span class="dv">361</span> (<span class="dv">32</span>)<span class="op">;</span> <span class="dv">21</span>:<span class="dv">84</span> <span class="dv">362</span>:<span class="dv">425</span> (<span class="dv">128</span>)<span class="op">;</span> <span class="dv">85</span>:<span class="dv">340</span></a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="dv">426</span>:<span class="dv">681</span> (<span class="dv">512</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">    g3 <span class="op">=</span> nx.balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb2-9" title="9">    g3a <span class="op">=</span> nx.convert_node_labels_to_integers(g3, first_label<span class="op">=</span>(order_tree <span class="op">*</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb2-10" title="10">    graphs.append(g3a)</a>
<a class="sourceLine" id="cb2-11" title="11">    forest2 <span class="op">=</span> nx.union_all(graphs)</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13">    f2d <span class="op">=</span> sym._format_graph_as_nauty(forest2)</a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="bu">print</span> sym._get_raw_nauty_output(f2d)</a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="dv">5</span> orbits<span class="op">;</span> grpsize<span class="op">=</span><span class="fl">5.395328432456e352</span><span class="op">;</span> <span class="dv">767</span> gens<span class="op">;</span> <span class="dv">256020</span> nodes<span class="op">;</span> maxlev<span class="op">=</span><span class="dv">613</span></a>
<a class="sourceLine" id="cb2-17" title="17">    cpu time <span class="op">=</span> <span class="fl">1.31</span> seconds</a>
<a class="sourceLine" id="cb2-18" title="18">     <span class="dv">0</span> <span class="dv">341</span> <span class="dv">682</span> (<span class="dv">3</span>)<span class="op">;</span> <span class="dv">1</span>:<span class="dv">4</span> <span class="dv">342</span>:<span class="dv">345</span> <span class="dv">683</span>:<span class="dv">686</span> (<span class="dv">12</span>)<span class="op">;</span> <span class="dv">5</span>:<span class="dv">20</span> <span class="dv">346</span>:<span class="dv">361</span> <span class="dv">687</span>:<span class="dv">702</span> (<span class="dv">48</span>)<span class="op">;</span> <span class="dv">21</span>:<span class="dv">84</span></a>
<a class="sourceLine" id="cb2-19" title="19">        <span class="dv">362</span>:<span class="dv">425</span> <span class="dv">703</span>:<span class="dv">766</span> (<span class="dv">192</span>)<span class="op">;</span> <span class="dv">85</span>:<span class="dv">340</span> <span class="dv">426</span>:<span class="dv">681</span> <span class="dv">767</span>:<span class="dv">1022</span> (<span class="dv">768</span>)<span class="op">;</span></a></code></pre></div>
<p>Adding a third balanced tree follows the same pattern. The only concern is the scaling of group size. Adding a fourth tree to give me some data points to work with.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">    g4 <span class="op">=</span> nx.balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">    g4a <span class="op">=</span> nx.convert_node_labels_to_integers(g4, first_label<span class="op">=</span>(order_tree <span class="op">*</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb3-3" title="3">    graphs.append(g4a)</a>
<a class="sourceLine" id="cb3-4" title="4">    forest3 <span class="op">=</span> nx.union_all(graphs)</a>
<a class="sourceLine" id="cb3-5" title="5">    f3d <span class="op">=</span> sym._format_graph_as_nauty(forest3)</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="bu">print</span> sym._get_raw_nauty_output(f3d)</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="dv">5</span> orbits<span class="op">;</span> grpsize<span class="op">=</span><span class="fl">4.487799270734e470</span><span class="op">;</span> <span class="dv">1023</span> gens<span class="op">;</span> <span class="dv">444760</span> nodes<span class="op">;</span> maxlev<span class="op">=</span><span class="dv">817</span></a>
<a class="sourceLine" id="cb3-9" title="9">    cpu time <span class="op">=</span> <span class="fl">3.10</span> seconds</a>
<a class="sourceLine" id="cb3-10" title="10">     <span class="dv">0</span> <span class="dv">341</span> <span class="dv">682</span> <span class="dv">1023</span> (<span class="dv">4</span>)<span class="op">;</span> <span class="dv">1</span>:<span class="dv">4</span> <span class="dv">342</span>:<span class="dv">345</span> <span class="dv">683</span>:<span class="dv">686</span> <span class="dv">1024</span>:<span class="dv">1027</span> (<span class="dv">16</span>)<span class="op">;</span> <span class="dv">5</span>:<span class="dv">20</span> <span class="dv">346</span>:<span class="dv">361</span></a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="dv">687</span>:<span class="dv">702</span> <span class="dv">1028</span>:<span class="dv">1043</span> (<span class="dv">64</span>)<span class="op">;</span> <span class="dv">21</span>:<span class="dv">84</span> <span class="dv">362</span>:<span class="dv">425</span> <span class="dv">703</span>:<span class="dv">766</span> <span class="dv">1044</span>:<span class="dv">1107</span> (<span class="dv">256</span>)<span class="op">;</span> <span class="dv">85</span>:<span class="dv">340</span></a>
<a class="sourceLine" id="cb3-12" title="12">        <span class="dv">426</span>:<span class="dv">681</span> <span class="dv">767</span>:<span class="dv">1022</span> <span class="dv">1108</span>:<span class="dv">1363</span> (<span class="dv">1024</span>)<span class="op">;</span></a></code></pre></div>
<p>The exponent is definitely going up as the power of the number of trees: <span class="math inline">\({10^{117}}^2 = 10^{234}\)</span>, and so on. But the other values are rising as well, and not by a simple multiplicative factor (which looked like 2). It looks like <span class="math inline">\(n!\)</span>.</p>
<p>So, with a forest of identical trees, with n trees, and <span class="math inline">\(s = |\textit{Aut}(g)|\)</span> for each tree, the total automorphism group size for the entire forest is thus <span class="math inline">\(n! s^n\)</span>. This is true for identical tree copies, but obviously more complex for non-identical components. We would not also see orbit multiplicities which are a simple factor of the base orbit multiplicity, and we’d expect that the orbit number would not be constant, of course.</p>
<p>This turns out to be a well-known result in graph theory, and applicable to any set of repeated graphs, not just trees. Frucht <span class="citation" data-cites="frucht1949groups">(1949)</span> gave the theorem but no explicit proof. But it’s easy to see why this is true. Take a graph <span class="math inline">\(G\)</span> with <span class="math inline">\(n\)</span> copies of a connected component, <span class="math inline">\(H\)</span>. For each of the <span class="math inline">\(n\)</span> copies of <span class="math inline">\(H\)</span>, there are <span class="math inline">\(s = |\textit{Aut}(H)|\)</span> automorphisms which map vertices <em>within</em> each copy. Thus there are <span class="math inline">\(s^n\)</span> total automorphisms which perform mappings within a single copy of <span class="math inline">\(H\)</span>. Then, we consider automorphisms between the identical copies, and find that there are <span class="math inline">\(n!\)</span> ways of permuting each automorphism with vertices from the <span class="math inline">\(n\)</span> copies. The total is thus <span class="math inline">\(n! s^n\)</span>. Another way to think of this is that we are doing the cartesian product of the symmetric group <span class="math inline">\(S_n\)</span> which gives all permutations of <span class="math inline">\(n\)</span> elements, with the direct product of all the copies. I believe this is called an “external wreath product”.</p>
<p>So how do the orbit numbers etc behave with multiple non-identical components?</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python numberLines"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">    gx1 <span class="op">=</span> nx.balanced_tree(<span class="dv">3</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-2" title="2">    nx1 <span class="op">=</span> stats.num_nodes_balanced_tree(<span class="dv">3</span>,<span class="dv">3</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">    gx2 <span class="op">=</span> nx.balanced_tree(<span class="dv">4</span>,<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb4-4" title="4">    gx2a <span class="op">=</span> nx.convert_node_labels_to_integers(gx2, first_label<span class="op">=</span>nx1)</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">    graphs2 <span class="op">=</span> []</a>
<a class="sourceLine" id="cb4-7" title="7">    graphs2.append(gx1)</a>
<a class="sourceLine" id="cb4-8" title="8">    graphs2.append(gx2a)</a>
<a class="sourceLine" id="cb4-9" title="9">    foresth1 <span class="op">=</span> nx.union_all(graphs2)</a>
<a class="sourceLine" id="cb4-10" title="10"></a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="bu">print</span> sym._get_raw_nauty_output(sym._format_graph_as_nauty(foresth1))</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="dv">9</span> orbits<span class="op">;</span> grpsize<span class="op">=</span><span class="fl">2.715950187930e127</span><span class="op">;</span> <span class="dv">281</span> gens<span class="op">;</span> <span class="dv">36753</span> nodes<span class="op">;</span> maxlev<span class="op">=</span><span class="dv">225</span></a>
<a class="sourceLine" id="cb4-14" title="14">    cpu time <span class="op">=</span> <span class="fl">0.06</span> seconds</a>
<a class="sourceLine" id="cb4-15" title="15">     <span class="dv">0</span><span class="op">;</span> <span class="dv">1</span>:<span class="dv">3</span> (<span class="dv">3</span>)<span class="op">;</span> <span class="dv">4</span>:<span class="dv">12</span> (<span class="dv">9</span>)<span class="op">;</span> <span class="dv">13</span>:<span class="dv">39</span> (<span class="dv">27</span>)<span class="op">;</span> <span class="dv">40</span><span class="op">;</span> <span class="dv">41</span>:<span class="dv">44</span> (<span class="dv">4</span>)<span class="op">;</span> <span class="dv">45</span>:<span class="dv">60</span> (<span class="dv">16</span>)<span class="op">;</span> <span class="dv">61</span>:<span class="dv">124</span> (<span class="dv">64</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-16" title="16">        <span class="dv">125</span>:<span class="dv">380</span> (<span class="dv">256</span>)<span class="op">;</span></a></code></pre></div>
<p>So…since the graph components are different, the orbits are disjoint and restricted to their own component. The total orbit number is simply the sum of the orbit numbers for the two components, and the orbit multiplicites and vertex membership are obviously restricted to each component (easy to see given the sequential vertex numbering).</p>
<p>The group size is greater than that of a single tree, but many orders of magnitude smaller than the combined group size of two identical trees. This likely reflects there being very few automorphisms between trees. In fact, the total group size is simply the product of the individual components: <span class="math inline">\(s = |\textit{Aut}(G_1)||\textit{Aut}(G_2)|\ldots|\textit{Aut}(G_n)|\)</span>. This means that the automorphism group of non-identical graph components taken together as a single graph with multiple components is the “direct product” of the individual components. What’s missing from the simple direct product is the interaction across components, which I suspect is what makes the above calculation a “wreath product,” although I don’t fully understand the latter yet.</p>
<h3 id="references-cited" class="unnumbered">References Cited</h3>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-frucht1949groups">
<p>Frucht, Robert. 1949. “On the Groups of Repeated Graphs.” <em>Bulletin of the American Mathematical Society</em> 55 (4): 418–20.</p>
</div>
</div>
:ET