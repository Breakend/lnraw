---
layout: post
title: Continuous Integration and Testing for Simulation Codes
tags: [experiments, simulation, open science, reproducible science]
category: essays
---

This week I added all of my simulation projects to the [Travis CI continuous integration](https://travis-ci.org/) system.  Travis is a hosted service, running a Ruby-based project which will check out your code from Github, run it on a clean virtual machine preloaded with common build tools and pieces of infrastructure (e.g., databases, libraries), and perform your unit or functional tests.  

Travis reports by email and in their web interface, of course, but more importantly, each project has a "badge" or icon which can be included in the project's `README.md` on Github, and which shows whether the build is broken, or passing all tests.  This is an improvement to simply having unit or functional tests in one's project, because the public can understand whether a project is working without downloading and building it.  

Here, for example, is the status of my current projects:

* `CTPy`:  [![Build Status](https://travis-ci.org/mmadsen/CTPy.svg?branch=master)](https://travis-ci.org/mmadsen/CTPy)
* `axelrod-ct`:  [![Build Status](https://travis-ci.org/mmadsen/axelrod-ct.svg?branch=master)](https://travis-ci.org/mmadsen/axelrod-ct)
* `ctmixtures`: [![Build Status](https://travis-ci.org/mmadsen/ctmixtures.svg?branch=master)](https://travis-ci.org/mmadsen/ctmixtures)

and several of their common code dependencies:

* `pytransmission`: [![Build Status](https://travis-ci.org/mmadsen/pytransmission.svg?branch=master)](https://travis-ci.org/mmadsen/pytransmission)
* `mmadsenr`: [![Build Status](https://travis-ci.org/mmadsen/mmadsenr.svg?branch=master)](https://travis-ci.org/mmadsen/mmadsenr)

I also found that Travis drastically improved the installability (and thus reproducibility) of my projects, especially across platforms.  All of the projects listed here are based on Python 2.7, but they rely on a variety of dependencies, some of which link to common (but very large) C++ libraries and others linked Python to my own C code via the SWIG code generator.  In one's own work, none of this infrastructure ever gets built all at once -- instead, it evolves in one's development environment as capabilities are added.  So it is easy to forget what a __complete__ build process looks like.  

Travis forced me to iterate on build and test scripts until every dependency was accounted for, and could be added (via `apt`) or built from scratch, on a clean Ubuntu 12.04 LTS system.  So I am sure that on a stock Ubuntu system, anybody can install any of the projects listed here (although I still need to add a manual install script to each project to replicate what Travis does).  

I do hope that the Travis folks add options for more build environments.  It was very hard, for example, to get a modern version of `SciPy` working on Ubuntu 12.04 LTS.  The stock version is too old to have the special mathematical functions library, so you have to build it from scratch.  Which takes __forever__.  The projects above take from 6 seconds to 3 minutes to build and test.  Except for `axelrod-ct`, which takes 24 minutes.  23 of which are simply building `scipy` -- every time I make a change.  That inefficiency could be solved by having a more recent binary package for 12.04, or test environments based upon something more recent in the Ubuntu lineup (say, 13.10).  




